
Features::
RECURSIVE_GENERATOR
  - have a generator which calls itself depending on the input value.
    To deal with this:
        bound number of appearances of a function on the stack to
        --bnd-inline-amount. Assert no more are needed.
        So, if you exceed the limit, assert false and return error.

PRAGMA
  * support: pragma options "--bnd-intbits 6";
    2. Pass bnd_foo parameters as arguments instead of statically defining
    3. Read bnd_foo parameters from the command line
    4. Read bnd_foo parameters from the options pragma.

BULK_ARRAY_EVAL
  * evaluate (statically) as necessary to determine bulk array bounds.

POOR_TYPE_BULK_ASSIGN
  * support something like: out[36::92] = (bit[92]) in;

POOR_TYPE_BIT_LITERAL
  * bit N = 5;

BULK_ASSIGN_BUG
  * there must be a bug in bulk assignment, because it doesn't work right.

COND_OPERATOR
  * (foo ? a : b)

FAIL_LAZY
  * divide by zero failure is not lazy for rem.
    We could fix this by: explicitly saying rem with 0 as the divider is
    error. (except, this doesn't seem to have actually fixed it...)
    Or by: in the threaded runtime, it should just work hopefully.

Features needed, by test case::
miniTest12.sk: RECURSIVE_GENERATOR
miniTest41.sk: SLOW? (It contains nested repeats of arbitrary depth)
miniTest49.sk: PRAGMA
miniTest50.sk: FAIL_LAZY
miniTest54.sk: PRAGMA
miniTest60.sk: BULK_ARRAY_EVAL
miniTest62.sk: BULK_ARRAY_EVAL
miniTest68.sk: BULK_ARRAY_EVAL
miniTest71.sk: POOR_TYPE_BULK_ASSIGN
miniTest72.sk: BULK_ASSIGN_BUG
miniTest73.sk: BULK_ASSIGN_BUG
miniTest77.sk: COND_OPERATOR
miniTest78.sk: POOR_TYPE_BIT_LITERAL
miniTest82.sk: BULK_ARRAY_EVAL
miniTest83.sk: BULK_ARRAY_EVAL
miniTest84.sk: BULK_ARRAY_EVAL
miniTest86.sk: BULK_ARRAY_EVAL
miniTest86.sk: BULK_ARRAY_EVAL
miniTest89.sk: SLOW? (quadratic in int space?)
miniTest90.sk: COND_OPERATOR

Pretty Print::
* for loop init and incr don't print properly

Cleanup::
* Many bits array operations don't depend on the width, can we 
  share these implementations with the array operations?

Refactor Ideas::
* Do more stuff in Static pass
    * Loops can be unrolled properly if bounds known statically.
    * We can inline generator functions here.

Performance Ideas:: (consider only AFTER we run into performance problems)
* split a program into independent pieces if there are any?
* perform simplification at start to avoid re-evaluating things we know every
  iteration of the CEGIS loop?
    This would also help with implementing repeat properly, and static
    evaluation of types.
* do incremental unrolling on the size of inputs and holes we try?

