Features::
POOR_TYPE_BIT_LITERAL
  * bit N = 5;
  Works at global scope after inlining, but not locally.
  I think this is a bug in the original sketch implementation. Should I
  emulate the bug, or try to have them fix the original sketch implementation?

UNINTERPRETED_FUNCTION
  * Support: int moo(int x);   at top level.
  Not sure how to implement this.
  Maybe: replace each call moo(x) with a new free variable y.
         collect all the pairs (x, y) used during execution,
         and at the end assert they have the function property:
  if x0 = x1 then y0 = y1
  if x0 = x2 then y0 = y2
  if x1 = x2 then y1 = y2
  etc...

STRUCT_TYPES
  * support struct types.

2D_UPDATE
  * support 2d array update: T[2][1] = 1;
    And, ideally, any dimension array update.

STATIC_EVAL::
  Evaluate local variables statically if possible.
  Because we might have:
    int x = foo(K);
    bit bar[x] = ...
  So we have to inline x to know the type of bar.
  Question: don't we already have some infrastructure for this?

TYPEOFV_SLOW
 Looks like we are getting stuck in a false infinite finite formula.
 See broken/perf0.smten.sk for minimized test case.
 

INSERTVAR_SLOW
 95% time is spent in insertVar, and the program doesn't finish.
 Particularly, that 95% is a result of a seemingly exponential blowup of calls
 to PRIM_INT_EQ, PRIM_INT_LEQ, and PRIM_INT_ADD.
 Ex: 175 calls to PRIM_INT_ADD lead to about 17 million calls to select.
 See broken/perf1.smten.sk for a minimized test case.

ARRUPD_SLOW
 100% time is spent in arrupd
 

INTEQ_SLOW
 All the time is spent in Int equality. Perhaps some algebraic 
 simplifications are needed?

STACK_OVERFLOW
 A mysterious stack overflow

Features needed, by test case::
broken/perf0.smten.sk: TYPEOFV_SLOW
broken/perf1.smten.sk: INSERVAR_SLOW
broken/repeat.smten.sk: ARRUPD_SLOW
broken/miniTest48.sk: STACK_OVERFLOW
broken/miniTest49.sk: INSERTVAR_SLOW
broken/miniTest52.sk: INSERTVAR_SLOW
miniTest54.sk: STATIC_EVAL
miniTest78.sk: POOR_TYPE_BIT_LITERAL
miniTest86.sk: INSERTVAR_SLOW
miniTest93.sk: UNINTERPRETED_FUNCTION
miniTestb101.sk: UNINTERPRETED_FUNCTION
miniTestb102.sk: TYPEOFV_SLOW
miniTestb103.sk: TYPEOFV_SLOW
miniTestb104.sk: TYPEOFV_SLOW
miniTestb107.sk: TYPEOFV_SLOW
miniTestb110.sk: INSERTVAR_SLOW
miniTestb111.sk: STRUCT_TYPES
miniTestb112.sk: STACK_OVERFLOW
miniTestb113.sk: 2D_UPDATE
miniTestb114.sk: STRUCT_TYPES
miniTestb116.sk: STRUCT_TYPES
miniTestb118.sk: INSERTVAR_SLOW
miniTestb121.sk: INTEQ_SLOW

Pretty Print::
* in type errors: pretty print types, don't just "show" them
* is it safe to print bit as 'true' and 'false'? What if they are used as int?
* don't need parens around integer literals
* 'for loop' init and incr don't print properly

Refactor Ideas::
* Do more stuff in Static pass
    * Loops can be unrolled properly if bounds known statically.
    * We can inline generator functions here.

Performance Ideas:: (consider only AFTER we run into performance problems)
* split a program into independent pieces if there are any?
* perform simplification at start to avoid re-evaluating things we know every
  iteration of the CEGIS loop?
    This would also help with implementing repeat properly, and static
    evaluation of types.
* do incremental unrolling on the size of inputs and holes we try?

