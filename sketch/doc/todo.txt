
Features::
STRUCTS
  * Support unboxed structs, with syntax |Foo| for the type.

UNINTERPRETED_FUNCTION
  * Support: int moo(int x);   at top level.
  Not sure how to implement this.
  Maybe: replace each call moo(x) with a new free variable y.
         collect all the pairs (x, y) used during execution,
         and at the end assert they have the function property:
  if x0 = x1 then y0 = y1
  if x0 = x2 then y0 = y2
  if x1 = x2 then y1 = y2
  etc...

FLOATS
  Support double and float.

STATIC_EVAL::
  Evaluate local variables statically if possible.
  Because we might have:
    int x = foo(K);
    bit[x] bar = ...
  So we have to inline x to know the type of bar.
  Question: don't we already have some infrastructure for this?
  Question: perhaps an alternate approach would be to allow dynamic
    array lengths in general?
  Operations to support at least:
    * multiplication, addition
    * left shift
    * constant variable
  Other things to do:
    * Keep track of values in the type environment if we have them statically

INSERT_INTO
  insert and into statements? What do those mean?

TYPEOFV_SLOW
 Looks like we are getting stuck in a false infinite finite formula.

INSERTVAR_SLOW
 Stuck in false symbolic execution?

INTEQ_SLOW
 All the time is spent in Int equality. Perhaps some algebraic 
 simplifications are needed?

STACK_OVERFLOW
 A mysterious stack overflow

PERF3
 In pc[1] < 4, 
 pc[1] can have so many possible values, we have an exponential blowup?
 Looks like it's from the short circuiting of &&, which actually requires
 a lot more work, because we don't know if we are allowed to short circuit 
 or not.

 Can we have the same control-flow path, independent of the value of the first
 argument to &&? Something like: predicated evaluation of the second argument.
 It only can cause failure if the predicate is true? That may or may not help.

PERF4
 See doc/perf4.txt

Features needed, by test case::

Sketch Inconsistencies
----------------------
tests/broken/expectfail/uninitint.smten.sk:
  Sketch is not consistent about whether ints are initialized or not.
  I assume they are initialized.

tests/broken/miniTest78.sk: poor type bit literal
  Sketch is not consistent about whether you can have:
     bit N = 5;
  In some contexts it says it's poorly typed, in other contexts it accepts
  it just fine. I think it's poorly typed.

tests/broken/bitarith.smten.sk, 
tests/broken/miniTestb215.sk,
tests/broken/miniTestb540.sk: bit supports + and -?
    The problem with these are, it's not clear what 1 + 1 is, or
    0 - 1 for bit. Then it's not clear that (-1) should be treated
    as an int, rather than a cast from (0 - 1) to an int, which would
    give the wrong result.    

Features Needed
---------------
tests/broken/miniTestb196.sk: support h_assert statement.
  After parsing of string literals is supported, probably just ignore the
  string argument and parse this as a normal assert.

tests/broken/miniTestb338.sk,
tests/broken/miniTest208Globals.sk,
tests/broken/miniTest209Globals.sk,
tests/broken/miniTestb399.sk,
tests/broken/miniTestb352.sk,
tests/broken/miniTestb442.sk,
tests/broken/miniTestb492.sk:
  Support use of global variables in normal code, not just type declarations.

tests/broken/miniTestb456.sk: Hole in type?
tests/broken/miniTestb231.sk: Hole in type?

tests/broken/miniTestb460.sk: minrepeat statement

tests/broken/miniTestb418.sk - empty array in initializer (parser bug)
tests/broken/miniTestb184.sk - REGEX_UPDATE:
  {| q(.a | .b) |} = n;
  Perhaps by making assignment an expression instead of a statement
  Note: sketch doesn't support (foo = bar) as an expression.
  This doesn't necessarily mean I can't.

tests/broken/annotations/*.sk: support @ annotations.
tests/broken/char/*.sk: CHAR_TYPE
tests/broken/cpp/*.sk: C preprocessor needed
tests/broken/double/*.sk: FLOATS
tests/broken/hfun/*.sk: higher order and local functions.
tests/broken/implicit/*.sk: implicit arguments
tests/broken/include/*.sk: include keyword
tests/broken/insertinto/*.sk: INSERT_INTO
tests/broken/package/*.sk: package keyword
tests/broken/static/*.sk: STATIC_EVAL
tests/broken/stencil/*.sk: stencil keyword
tests/broken/structs/*.sk: STRUCTS
tests/broken/uninterp/*.sk: UNINTERPRETED_FUNCTION
tests/broken/unknownN/*.sk: Global N not defined?

Performance Bugs
----------------
tests/broken/miniTestb112.sk: STACK_OVERFLOW: from REORDER statement?
tests/broken/miniTestb144.sk: STACK_OVERFLOW on many solvers
tests/broken/miniTestb153.sk: STACK_OVERFLOW on many solvers
tests/broken/miniTestb160.sk: STACK_OVERFLOW on STP
tests/broken/miniTestb161.sk: STACK_OVERFLOW on STP

tests/broken/slow/perf3.smten.sk: PERF3
tests/broken/slow/perf4.smten.sk: PERF4
tests/broken/slow/miniTestb102.sk: TYPEOFV_SLOW
tests/broken/slow/miniTestb103.sk: TYPEOFV_SLOW
tests/broken/slow/miniTestb104.sk: TYPEOFV_SLOW
tests/broken/slow/miniTestb110.sk: INSERTVAR_SLOW
tests/broken/slow/miniTestb121.sk: INTEQ_SLOW
tests/broken/slow/miniTestb147.sk: (==) takes all time?
tests/broken/slow/miniTestb180.sk: takes many iterations
tests/broken/slow/miniTestb180.sk: takes many iterations
tests/broken/slow/miniTestb181.sk: arrsub takes all time?
tests/broken/slow/miniTestb182.sk: takes many iterations
tests/broken/slow/miniTestb189.sk: (==) takes all time?
tests/broken/slow/miniTestb216.sk: slow: dominated by updateLV?
tests/broken/slow/miniTestb218.sk: slow: TODO: look into why
tests/broken/slow/miniTestb226.sk: slow on yices1, fine on yices2
tests/broken/slow/miniTestb276.sk: slow: why?
tests/broken/slow/miniTestb277.sk: slow: why?
tests/broken/slow/miniTestb278.sk: slow: why?
tests/broken/slow/miniTestb279.sk: slow: why?
tests/broken/slow/miniTestb280.sk: slow: why?
tests/broken/slow/miniTestb334.sk: STACK_OVERFLOW
tests/broken/slow/miniTestb366.sk: blowup of int possibilities
tests/broken/slow/miniTestb390.sk: STACK_OVERFLOW
tests/broken/slow/regex/*.sk: slow regex examples
  Perhaps because we enumerate the whole space with ChoiceE before
  making it symbolic? Would it be better to represent the choices
  explicitly in the syntax and let symbolic merge things?

Gallery
-------
gallery/Pollard.sk: memory blowup
gallery/SetTest.cpped.sk: REGEX_UPDATE
gallery/compress.sk: FINISHES
gallery/diagStencil.sk: STENCIL
gallery/diagStencilClean.sk: STENCIL
gallery/doublyLinkedList.sk: REGEX_UPDATE
gallery/enqueueSeqSK.sk: REGEX_UPDATE
gallery/isolateRightmost.sk: SLOW
  Looks like it's making an exponential tree of generators (tens of
  thousands), which is just leading to very large queries.
  Question: are generators inlined before or after regex choice?
  Answer: most likely before, but currently I do it after.
gallery/jburnim_morton.sk: FINISHES
gallery/karatsuba.sk: UNKNOWN_N
gallery/listReverse.sk: REGEX_PARSER
  {| null | ((l1 | l2)(.head | .tail) )(.next)? |} doesn't parse.
gallery/log2.sk: comma in global DeclS:
   int W = 32, logW = 5;
gallery/logcount.sk: FINISHES
gallery/lss.sk: REGEX_PARSER
    {| (sum | psum | ??) (+|-) (sum | psum | ??) |}
gallery/parity.sk: FINISHES
gallery/partition.cpped.sk: LOCAL_GEN
gallery/polynomial.sk: FINISHES
gallery/registerlesSwap.sk:  MINREPEAT
gallery/reverse.sk: SLOW
  looks like it will finish, just slow. Maybe 2 hours?
gallery/signedAvg.sk: UNKNOWN_N
gallery/sort.included.sk: LOCAL_GEN
gallery/talbeBasedAddition.sk: STATIC
  Static evaluation on local variables:
  int exp = 1 << W*2;
  bit [W*exp] tmp = ...
gallery/tutorial1.sk: FINISHES
gallery/tutorial2.sk: SLOW: memory blowup
  Because of int arithmetic blowup?
gallery/tutorial3.sk: SLOW: memory blowup
  Because of int arithmetic blowup?
gallery/xpose.sk: SLOW: memory blowup
 

Clean::
* Static phase does a lot of duplicated type evaluation.
  Perhaps do type evaluation in a dependency order kind of way using a state
  monad?
* Understand and remove conflicts in parser. (see doc/parser.txt)
* TODO's inlined


Pretty Print::
* in type errors: pretty print types, don't just "show" them

Refactor Ideas::
* Do more stuff in Static pass
    * Loops can be unrolled properly if bounds known statically.
    * We can inline generator functions here.

Performance Ideas:: (consider only AFTER we run into performance problems)
* split a program into independent pieces if there are any?
* perform simplification at start to avoid re-evaluating things we know every
  iteration of the CEGIS loop?
    This would also help with implementing repeat properly, and static
    evaluation of types.
* do incremental unrolling on the size of inputs and holes we try?
* Use "random" solver for synthesis query?

