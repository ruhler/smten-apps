Features::
RECURSIVE_GENERATOR
  - have a generator which calls itself depending on the input value.
    How to deal with this?
    Use the inlining bound?

TYPE_BUG
  - bit[4] x = ...
    if (x == 1) ...
      Currently we don't infer the type of '1' properly.

XOR_ARGS_BUG
  - miniTest19.sk is getting the wrong type of args to xor for some reason.

CHOICE - {|} hole generator
  - To implement: deHoleExpr should use mplus on both cases.
    This is relatively easy to implement.
    
FOR - support for loops
  
INTARRAY - int arrays

Operators (easy to implement):
 LOR: || boolean operator 


Features needed, by test case::
miniTest8.sk: TYPE_BUG
miniTest12.sk: RECURSIVE_GENERATOR
miniTest17.sk: ???
miniTest19.sk: XOR_ARGS_BUG
miniTest20.sk: INTARRAY
miniTest21.sk: INTARRAY
miniTest31.sk: CHOICE, LOR
miniTest32.sk: CHOICE
miniTest34.sk: INTARRAY
miniTest35.sk: INTARRAY
miniTest36.sk: INTARRAY
miniTest37.sk: INTARRAY
miniTest40.sk: ???
miniTest41.sk: ???
miniTest43.sk: LOR
miniTest44.sk: LOR

Performance Ideas:: (consider only AFTER we run into performance problems)
* split a program into independent pieces if there are any?
* perform simplification at start to avoid re-evaluating things we know every
  iteration of the CEGIS loop?
* do incremental unrolling on the size of inputs and holes we try?

Other Todo::
* make the pretty printer print prettier

Document Behaviors of sketch::
* if you call a function in two different sketches, are it's holes shared or
  duplicated? (that is, do we need to do everything at once, or one sketch at
  a time?)
* What happens to: ??[4] in terms of type inference?
    blows up
* what happens to: 7[2] in terms of type inference?
    blows up
* are < and > supported for bits?
* if you have a generate call inside a repeat block, is the generate call made
  repeatedly producing new holes each time, or is it called once with the same
  holes replicated?

