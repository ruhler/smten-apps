
Features::
POOR_TYPE_BIT_LITERAL
  * bit N = 5;
  Works at global scope after inlining, but not locally.
  I think this is a bug in the original sketch implementation. Should I
  emulate the bug, or try to have them fix the original sketch implementation?

UNINTERPRETED_FUNCTION
  * Support: int moo(int x);   at top level.
  Not sure how to implement this.
  Maybe: replace each call moo(x) with a new free variable y.
         collect all the pairs (x, y) used during execution,
         and at the end assert they have the function property:
  if x0 = x1 then y0 = y1
  if x0 = x2 then y0 = y2
  if x1 = x2 then y1 = y2
  etc...

STRUCT_TYPES
  Support struct types.
  Needs:
  * Declaration for struct.
  * StructT type
  * new operator: new Foo();
  * 'null' pointer.
  * member access via '.'  May be multi-level
  * member update via '.'  May be multi-level
  * passing structs as arguments
  

STATIC_EVAL::
  Evaluate local variables statically if possible.
  Because we might have:
    int x = foo(K);
    bit bar[x] = ...
  So we have to inline x to know the type of bar.
  Question: don't we already have some infrastructure for this?
  Operations to support at least:
    * multiplication, addition
    * left shift
    * constant variable
  Other things to do:
    * Keep track of values in the type environment if we have them statically

INCR_OP::
  Support pre and post increment and decrement in expressions.
  * add PostIncr, PostDecr, PreIncr, and PreDecr expressions.
    They should take an LVal argument.
  * switch to ExprS rather than desugar for statements which do these
    operations.
    

INSERT_INTO
  insert and into statements? What do those mean?

TYPEOFV_SLOW
 Looks like we are getting stuck in a false infinite finite formula.

INSERTVAR_SLOW
 Stuck in false symbolic execution?

INTEQ_SLOW
 All the time is spent in Int equality. Perhaps some algebraic 
 simplifications are needed?

STACK_OVERFLOW
 A mysterious stack overflow

MULTI_VARS
support multiple var decls on one line.
  ex: int x=0, y=0;

PERF3
 In pc[1] < 4, 
 pc[1] can have so many possible values, we have an exponential blowup?
 Looks like it's from the short circuiting of &&, which actually requires
 a lot more work, because we don't know if we are allowed to short circuit 
 or not.

 Can we have the same control-flow path, independent of the value of the first
 argument to &&? Something like: predicated evaluation of the second argument.
 It only can cause failure if the predicate is true? That may or may not help.

Features needed, by test case::

tests/broken/miniTest78.sk: POOR_TYPE_BIT_LITERAL
tests/broken/miniTest86.sk: WRONG ANSWER: says unsat
tests/broken/miniTestb112.sk: STACK_OVERFLOW: from REORDER statement?
tests/broken/miniTestb129.sk: MULTI_VARS
tests/broken/miniTestb130.sk: MULTI_VARS
tests/broken/miniTestb144.sk: STACK_OVERFLOW on many solvers
tests/broken/miniTestb153.sk: STACK_OVERFLOW on many solvers
tests/broken/miniTestb160.sk: STACK_OVERFLOW on STP
tests/broken/miniTestb161.sk: STACK_OVERFLOW on STP
tests/broken/miniTestb196.sk: support h_assert statement.

tests/broken/miniTestb208.sk,
tests/broken/miniTest213ArrExpScaling.sk,
tests/broken/miniTest215Choice.sk: C Preprocessor?

tests/broken/miniTestb209.sk: MULTI_VARS
tests/broken/miniTestb215.sk: TYPE ERROR - bit supports + and -?
tests/broken/miniTestb225.sk: C Preprocessor?
tests/broken/miniTestb232.sk: Uninitialized variable?
tests/broken/miniTestb279.sk: MULTI_VARS

tests/broken/miniTestb317.sk: INCR_OP
tests/broken/miniTestb318.sk: INCR_OP
tests/broken/miniTestb399.sk: INCR_OP
tests/broken/miniTestb419.sk: INCR_OP

tests/broken/miniTestb338.sk,
tests/broken/miniTest208Globals.sk,
tests/broken/miniTest209Globals.sk,
tests/broken/miniTestb352.sk:
  Support use of global variables in normal code, not just type declarations.

tests/broken/miniTestb345.sk: support == on general arrays.
tests/broken/miniTestb347.sk: MULTI_VARS
tests/broken/miniTestb366.sk:
  sketch takes reference parameter - but it's given no arguments to update?

tests/broken/annotations/*.sk: support @ annotations.
tests/broken/static/*.sk: STATIC_EVAL
tests/broken/structs/*.sk: STRUCT_TYPES
tests/broken/uninterp/*.sk: UNINTERPRETED_FUNCTION
tests/broken/hfun/*.sk: higher order and local functions.
tests/broken/void/*.sk: unclassified test cases
tests/broken/char/*.sk: CHAR_TYPE
tests/broken/include/*.sk: include keyword
tests/broken/package/*.sk: package keyword
tests/broken/insertinto/*.sk: INSERT_INTO
tests/broken/regex/*.sk: Support REGEX hole expressions.
tests/broken/stencil/*.sk: stencil keyword
tests/broken/unknownN/*.sk: Global N not defined?

tests/broken/slow/perf3.smten.sk: PERF3
tests/broken/slow/miniTestb102.sk: TYPEOFV_SLOW
tests/broken/slow/miniTestb103.sk: TYPEOFV_SLOW
tests/broken/slow/miniTestb104.sk: TYPEOFV_SLOW
tests/broken/slow/miniTestb110.sk: INSERTVAR_SLOW
tests/broken/slow/miniTestb121.sk: INTEQ_SLOW
tests/broken/slow/miniTestb147.sk: (==) takes all time?
tests/broken/slow/miniTestb180.sk: takes many iterations
tests/broken/slow/miniTestb180.sk: takes many iterations
tests/broken/slow/miniTestb181.sk: arrsub takes all time?
tests/broken/slow/miniTestb182.sk: takes many iterations
tests/broken/slow/miniTestb189.sk: (==) takes all time?
tests/broken/slow/miniTestb218.sk: slow: TODO: look into why
tests/broken/slow/miniTestb226.sk: slow on yices1, fine on yices2
tests/broken/slow/miniTestb276.sk: slow: why?
tests/broken/slow/miniTestb277.sk: slow: why?
tests/broken/slow/miniTestb278.sk: slow: why?
tests/broken/slow/miniTestb280.sk: slow: why?
tests/broken/slow/miniTestb334.sk: STACK_OVERFLOW
tests/broken/slow/miniTestb390.sk: STACK_OVERFLOW

Clean::
* TODO's inlined

Pretty Print::
* in type errors: pretty print types, don't just "show" them
* is it safe to print bit as 'true' and 'false'? What if they are used as int?
* don't need parens around integer literals
* 'for loop' init and incr don't print properly

Refactor Ideas::
* Do more stuff in Static pass
    * Loops can be unrolled properly if bounds known statically.
    * We can inline generator functions here.

Performance Ideas:: (consider only AFTER we run into performance problems)
* split a program into independent pieces if there are any?
* perform simplification at start to avoid re-evaluating things we know every
  iteration of the CEGIS loop?
    This would also help with implementing repeat properly, and static
    evaluation of types.
* do incremental unrolling on the size of inputs and holes we try?

