
Features::
RECURSIVE_GENERATOR
  - have a generator which calls itself depending on the input value.
    To deal with this:
        bound number of appearances of a function on the stack to
        --bnd-inline-amount. Assert no more are needed.
        So, if you exceed the limit, assert false and return error.

ASSIGN_BUG
  * keep type information for update.

SCALAR_ARRAY
  * automatically promote arbitrary scalars to one element arrays
    if needed. Not just integer literal scalars.

ARRAY_HOLE
  * int [8] fu = ??;  Should be allowed.

SUB_ARRAY
  * tmp[1::2] = ...;  Should be allowed.

MOD_OPERATOR
  * support: t % ?? for int type.

LAND_BITS
  * && operator should work on bits.

PRAGMA
  * support: pragma options "--bnd-intbits 6";

FAIL_EAGER
  * type errors sometimes cause things to hang rather than report the error.
    Is this a problem with smten?
    It's: do you want to treat error as anything, or raise errors right away,
    or what?

FAIL_LAZY
  * divide by zero failure is not lazy for rem.
    We could fix this by: explicitly saying rem with 0 as the divider is
    error. (except, this doesn't seem to have actually fixed it...)
    Or by: in the threaded runtime, it should just work hopefully.

Features needed, by test case::
tests/broken/expectfail/assigntosmaller.smten.sk: ASSIGN_BUG
tests/broken/expectfail/gtbitsbits.smten.sk: FAIL_EAGER
tests/broken/landbitsbits.smten.sk: LAND_BITS
tests/broken/miniTest3.sk: SCALAR_ARRAY

miniTest12.sk: RECURSIVE_GENERATOR
miniTest41.sk: SLOW? (It contains nested repeats of arbitrary depth)
miniTest49.sk: PRAGMA
miniTest50.sk: FAIL_LAZY
miniTest51.sk: ARRAY_HOLE
miniTest52.sk: DIV_OPERATOR
miniTest53.sk: SUB_ARRAY
miniTest54.sk: SUB_ARRAY
miniTest55.sk: SUB_ARRAY
miniTest60.sk: SUB_ARRAY
miniTest62.sk: SUB_ARRAY
miniTest63.sk: SLOW. Probably a type error that's being abstracted over.
miniTest67.sk: SCALAR_ARRAY
miniTest68.sk: SUB_ARRAY
miniTest69.sk: SUB_ARRAY
miniTest70.sk: SUB_ARRAY

Refactor Ideas::
* Separate Expr from Value
    So we can express at the type level when values are expected.
    * evalE should return a value
    * asint, astype should transform Value to Value
    * typeOf value should give a completely known type
* Have a separate Simplify pass before generate
    * We don't need 'evalT' all over the place anymore.
    * This computes everything we know statically.
    * Loops can be unrolled properly if bounds known statically.
    * We can inline generator functions here.

Pretty Printer::
* maintain tabs
* print empty statement as ";" instead of "{ }"

Performance Ideas:: (consider only AFTER we run into performance problems)
* split a program into independent pieces if there are any?
* perform simplification at start to avoid re-evaluating things we know every
  iteration of the CEGIS loop?
    This would also help with implementing repeat properly, and static
    evaluation of types.
* do incremental unrolling on the size of inputs and holes we try?
    
Other Todo::
* make the pretty printer print prettier

Document Behaviors of sketch::
* What happens to: ??[4] in terms of type inference?
    blows up
* what happens to: 7[2] in terms of type inference?
    blows up

