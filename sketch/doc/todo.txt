Features::
GENERATORS
  - To implement:
      Inline, then deHole. This should be done at generation time.
    Note: needs syntax for function calls, and presumably support for normal
    function calls (which deHole before inlining).

CHOICE - {|} hole generator
  - To implement: deHoleExpr should use mplus on both cases.
    This is relatively easy to implement.
    
HOLE_WIDTH - support for specified width holes
  - To implement: easy, add a bound to a hole, handle in deHoleExpr.

FOR - support for loops
  
INTARRAY - int arrays

Operators (easy to implement):
 LOR: || boolean operator 
 EQ - '==' operator
 PREINC - '++' prefix operator
 INTPLUS - integer plus


Features needed, by test case:;
miniTest5.sk: GENERATOR
miniTest8.sk: FOR
miniTest10.sk: HOLE_WIDTH, GENERATOR, EQ
miniTest11.sk: GENERATOR
miniTest12.sk: GENERATOR, 
miniTest16.sk: GENERATOR
miniTest17.sk: GENERATOR, FOR, PREINC
miniTest19.sk: GENERATOR
miniTest20.sk: HOLE_WIDTH, INTARRAY
miniTest21.sk: PREINC
miniTest25.sk: GENERATOR
miniTest30.sk: INTPLUS, GENERATOR
miniTest31.sk: CHOICE, LOR

Performance Ideas:: (consider only AFTER we run into performance problems)
* split a program into independent pieces if there are any?
* perform simplification at start to avoid re-evaluating things we know every
  iteration of the CEGIS loop?
* do incremental unrolling on the size of inputs and holes we try?

Other Todo::
* make the pretty printer print prettier
* reuse BlockS for handling function bodies? 
* clean up type inference (leverage an smt solver?)

Document Behaviors of sketch::
* if you call a function in two different sketches, are it's holes shared or
  duplicated? (that is, do we need to do everything at once, or one sketch at
  a time?)
* What happens to: ??[4] in terms of type inference?
    blows up
* what happens to: 7[2] in terms of type inference?
    blows up
* are < and > supported for bits?

