
Features::
FAIL_LAZY
  * divide by zero failure is not lazy for rem.
    We could fix this by: explicitly saying rem with 0 as the divider is
    error. (except, this doesn't seem to have actually fixed it...)
    Or by: in the threaded runtime, it should just work hopefully.

  * out of bounds array access is also not lazy.

  The problem is with how the evaluation monad is structured. It doesn't
  "fail" if an assertion fails. Rather, it marks a flag as false, but
  continues executing based on the result value. This continued execution
  causes the result value to be forced, even if the assertion is False.

  To fix it, change the evaluation monad to an error monad.

RECURSIVE_GENERATOR
  - have a generator which calls itself depending on the input value.
    To deal with this:
        bound number of appearances of a function on the stack to
        --bnd-inline-amnt. Assert no more are needed.
        So, if you exceed the limit, assert false and return error.

POOR_TYPE_BIT_LITERAL
  * bit N = 5;
  Works at global scope after inlining, but not locally.
  I think this is a bug in the original sketch implementation. Should I
  emulate the bug, or try to have them fix the original sketch implementation?

UNINTERPRETED_FUNCTION
  * Support: int moo(int x);   at top level.
  Not sure how to implement this.

INT_SHIFTL
  * Support: int exp = 1 << (K*2)
        for K int
  Tedious, but straight forward to implement.
  Just multiply by 2 repeatedly.

STRUCT_TYPES
  * support struct types.

REORDER
  * support reorder block
  Not clear what reorder block is, though intuitively, it's any permutation of
  the given statements.
    reorder { a; b }
   is: 
    bit x = ??; 
    if x { a ; b} else { b ; a }
  or: bit x = ??;
      if x { a }
      b
      if !x { a } 
    reorder { a; b; c}
        is:   a ; reorder { b; c}
           |  b ; reorder { a; c}
           |  c ; reorder { a; b}
    

2D_UPDATE
  * support 2d array update: T[2][1] = 1;
    And, ideally, any dimension array update.

PRAGMA::
  Read options from pragmas.
  * Have a Pragma declaration, which is read after parsing, but otherwise
    ignored. 
  * change args parser to accept existing args as a baseline, so that we can
    update the args based on pragma options.

Features needed, by test case::
broken/*.sk: FAIL_LAZY
broken/cbitsA.smten.sk: PRAGMA
miniTest12.sk: RECURSIVE_GENERATOR
miniTest41.sk: SLOW? (It contains nested repeats of arbitrary depth)
miniTest50.sk: FAIL_LAZY
miniTest54.sk: INT_SHIFTL
miniTest78.sk: POOR_TYPE_BIT_LITERAL
miniTest84.sk: FAIL_LAZY
miniTest86.sk: FAIL_LAZY
miniTest89.sk: SLOW: takes 20 seconds about
               It most certainly should *not*. Why is it so slow?
               To figure out: make inbits a cmd line arg, and see how it
               scales from 1 bit up to whatever the default is.
miniTest93.sk: UNINTERPRETED_FUNCTION
miniTestb101.sk: UNINTERPRETED_FUNCTION
miniTestb102.sk: SLOW?
miniTestb103.sk: SLOW?
miniTestb104.sk: SLOW?
miniTestb107.sk: SLOW?
miniTestb110.sk: SLOW?
miniTestb111.sk: STRUCT_TYPES
miniTestb112.sk: REORDER
miniTestb113.sk: 2D_UPDATE
miniTestb114.sk: STRUCT_TYPES
miniTestb116.sk: STRUCT_TYPES

Pretty Print::
* in type errors: pretty print types, don't just "show" them
* is it safe to print bit as 'true' and 'false'? What if they are used as int?
* don't need parens around integer literals
* 'for loop' init and incr don't print properly

Options:: (like --bnd-ictrl, --bnd-inbits, etc...)
* Understand what they are, what they are called, and what they really do
* Implement them properly
* Accept them from the command line
* Accept them in the form of pragmas

Refactor Ideas::
* Do more stuff in Static pass
    * Loops can be unrolled properly if bounds known statically.
    * We can inline generator functions here.

Performance Ideas:: (consider only AFTER we run into performance problems)
* split a program into independent pieces if there are any?
* perform simplification at start to avoid re-evaluating things we know every
  iteration of the CEGIS loop?
    This would also help with implementing repeat properly, and static
    evaluation of types.
* do incremental unrolling on the size of inputs and holes we try?

