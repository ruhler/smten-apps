Features::
POOR_TYPE_BIT_LITERAL
  * bit N = 5;
  Works at global scope after inlining, but not locally.
  I think this is a bug in the original sketch implementation. Should I
  emulate the bug, or try to have them fix the original sketch implementation?

UNINTERPRETED_FUNCTION
  * Support: int moo(int x);   at top level.
  Not sure how to implement this.
  Maybe: replace each call moo(x) with a new free variable y.
         collect all the pairs (x, y) used during execution,
         and at the end assert they have the function property:
  if x0 = x1 then y0 = y1
  if x0 = x2 then y0 = y2
  if x1 = x2 then y1 = y2
  etc...

STRUCT_TYPES
  Support struct types.
  Needs:
  * Declaration for struct.
  * StructT type
  * new operator: new Foo();
  * 'null' pointer.
  * member access via '.'  May be multi-level
  * member update via '.'  May be multi-level
  * passing structs as arguments
  

2D_UPDATE
  Support 2d array update: T[2][1] = 1;
  And, ideally, any dimension array update.
  Maybe: Have a generic Assign operator, and LVal?

STATIC_EVAL::
  Evaluate local variables statically if possible.
  Because we might have:
    int x = foo(K);
    bit bar[x] = ...
  So we have to inline x to know the type of bar.
  Question: don't we already have some infrastructure for this?
  Operations to support at least:
    * multiplication, addition
    * left shift
    * constant variable
  Other things to do:
    * Keep track of values in the type environment if we have them statically

HARNESS::
  Support the 'harness' declaration.

VOID_TYPE::
  Support the type 'void' for functions.
  * What value should be returned for void?
     In order to ensure two void type functions are the same?
     What does a function return if it doesn't include a return statement?
      - for a void function, it should return void
      - for an int or bit function??
  * Add expression statement (which must have type void?)
  * Support reference parameters
  * Support empty return statement: return;

INSERT_INTO
  insert and into statements? What do those mean?

TYPEOFV_SLOW
 Looks like we are getting stuck in a false infinite finite formula.

INSERTVAR_SLOW
 Stuck in false symbolic execution?

INTEQ_SLOW
 All the time is spent in Int equality. Perhaps some algebraic 
 simplifications are needed?

STACK_OVERFLOW
 A mysterious stack overflow

PERF3
 In pc[1] < 4, 
 pc[1] can have so many possible values, we have an exponential blowup?
 Looks like it's from the short circuiting of &&, which actually requires
 a lot more work, because we don't know if we are allowed to short circuit 
 or not.

 Can we have the same control-flow path, independent of the value of the first
 argument to &&? Something like: predicated evaluation of the second argument.
 It only can cause failure if the predicate is true? That may or may not help.

Features needed, by test case::

tests/broken/miniTest78.sk: POOR_TYPE_BIT_LITERAL
tests/broken/miniTest86.sk: WRONG ANSWER: says unsat
tests/broken/miniTestb112.sk: STACK_OVERFLOW: from REORDER statement?
tests/broken/miniTestb113.sk: 2D_UPDATE
tests/broken/miniTestb144.sk: STACK_OVERFLOW on many solvers
tests/broken/miniTestb153.sk: STACK_OVERFLOW on many solvers
tests/broken/miniTestb160.sk: STACK_OVERFLOW on STP
tests/broken/miniTestb161.sk: STACK_OVERFLOW on STP
tests/broken/miniTestb157.sk: 2D_UPDATE
tests/broken/miniTestb205.sk: TYPE ERROR
tests/broken/miniTestb206.sk: TYPE ERROR
tests/broken/miniTestb208.sk: C Preprocessor?
tests/broken/miniTestb215.sk: TYPE ERROR - parser precedence bug?
tests/broken/miniTestb225.sk: C Preprocessor?
tests/broken/miniTestb338.sk: Can't find variable in scope
tests/broken/miniTestb533.sk: Empty file?

tests/broken/harness/*.sk: HARNESS
tests/broken/static/*.sk: STATIC_EVAL
tests/broken/structs/*.sk: STRUCT_TYPES
tests/broken/uninterp/*.sk: UNINTERPRETED_FUNCTION
tests/broken/void/*.sk: VOID_TYPE
tests/broken/char/*.sk: CHAR_TYPE
tests/broken/include/*.sk: include keyword
tests/broken/package/*.sk: package keyword
tests/broken/insertinto/*.sk: INSERT_INTO
tests/broken/regex/*.sk: Support REGEX hole expressions.
tests/broken/stencil/*.sk: stencil keyword
tests/broken/unknownN/*.sk: Global N not defined?

tests/broken/slow/perf3.smten.sk: PERF3
tests/broken/slow/miniTestb102.sk: TYPEOFV_SLOW
tests/broken/slow/miniTestb103.sk: TYPEOFV_SLOW
tests/broken/slow/miniTestb104.sk: TYPEOFV_SLOW
tests/broken/slow/miniTestb110.sk: INSERTVAR_SLOW
tests/broken/slow/miniTestb121.sk: INTEQ_SLOW
tests/broken/slow/miniTestb147.sk: (==) takes all time?
tests/broken/slow/miniTestb180.sk: takes many iterations
tests/broken/slow/miniTestb180.sk: takes many iterations
tests/broken/slow/miniTestb181.sk: arrsub takes all time?
tests/broken/slow/miniTestb182.sk: takes many iterations
tests/broken/slow/miniTestb189.sk: (==) takes all time?

Pretty Print::
* in type errors: pretty print types, don't just "show" them
* is it safe to print bit as 'true' and 'false'? What if they are used as int?
* don't need parens around integer literals
* 'for loop' init and incr don't print properly

Refactor Ideas::
* Do more stuff in Static pass
    * Loops can be unrolled properly if bounds known statically.
    * We can inline generator functions here.

Performance Ideas:: (consider only AFTER we run into performance problems)
* split a program into independent pieces if there are any?
* perform simplification at start to avoid re-evaluating things we know every
  iteration of the CEGIS loop?
    This would also help with implementing repeat properly, and static
    evaluation of types.
* do incremental unrolling on the size of inputs and holes we try?

