
Features::
RECURSIVE_GENERATOR
  - have a generator which calls itself depending on the input value.
    To deal with this:
        bound number of appearances of a function on the stack to
        --bnd-inline-amount. Assert no more are needed.
        So, if you exceed the limit, assert false and return error.

POOR_TYPE_BIT_LITERAL
  * bit N = 5;

UNINTERPRETED_FUNCTION
  * Support: int moo(int x);   at top level.

UNIFY_INT_BIT
  * int and bit should unify to int.

ARRAY_ACCESS_BUG
  * array access is encountering a non-array thing
    Why isn't this caught by static typing?

INT_SHIFTL
  * Support: int exp = 1 << (K*2)
        for K int

ICAST_BITS_TO_INTS
  * implicit cast should support converting an array of bits to an array of
    ints. And, more generally, casting each element of an array up, not just
    the width of the array.
   We may want to right a recursive procedure for this.

BIT_INT_UNIFY_BUG
  There appears to be some bug in unification of bit and int types.
  I'm not sure what's going on.

OUT_OF_BOUNDS_ACCESS
  * looks like an out of bounds array access.
    I suspect: we need a dynamic assertion for bulk array update bounds
        (see TODO in code)

STRUCT_TYPES
  * support struct types.

FAIL_LAZY
  * divide by zero failure is not lazy for rem.
    We could fix this by: explicitly saying rem with 0 as the divider is
    error. (except, this doesn't seem to have actually fixed it...)
    Or by: in the threaded runtime, it should just work hopefully.
  

Features needed, by test case::
tests/broken/miniTest21.sk: ICAST_BITS_TO_INTS
miniTest12.sk: RECURSIVE_GENERATOR
miniTest41.sk: SLOW? (It contains nested repeats of arbitrary depth)
miniTest50.sk: FAIL_LAZY
miniTest54.sk: INT_SHIFTL
miniTest78.sk: POOR_TYPE_BIT_LITERAL
miniTest83.sk: ICAST_BITS_TO_INTS
miniTest84.sk: ICAST_BITS_TO_INTS
miniTest86.sk: OUT_OF_BOUNDS_ACCESS
miniTest89.sk: SLOW? (quadratic in int space?)
miniTest93.sk: UNINTERPRETED_FUNCTION
miniTestb101.sk: UNINTERPRETED_FUNCTION
miniTestb102.sk: ARRAY_ACCESS_BUG
miniTestb103.sk: SLOW? Not sure why
miniTestb104.sk: ICAST_BITS_TO_INTS
miniTestb107.sk: ICAST_BITS_TO_INTS
miniTestb108.sk: BIT_INT_UNIFY_BUG
miniTestb109.sk: BIT_INT_UNIFY_BUG
miniTestb110.sk: BIT_INT_UNIFY_BUG
minitestb111.sk: STRUCT_TYPES

Pretty Print::
* in type errors: pretty print types, don't just "show" them
* is it safe to print bit as 'true' and 'false'? What if they are used as int?
* don't need parens around integer literals
* 'for loop' init and incr don't print properly

Options:: (like --bnd-ictrl, --bnd-inbits, etc...)
* Understand what they are, what they are called, and what they really do
* Implement them properly
* Accept them from the command line
* Accept them in the form of pragmas

Refactor Ideas::
* Do more stuff in Static pass
    * Loops can be unrolled properly if bounds known statically.
    * We can inline generator functions here.

Performance Ideas:: (consider only AFTER we run into performance problems)
* split a program into independent pieces if there are any?
* perform simplification at start to avoid re-evaluating things we know every
  iteration of the CEGIS loop?
    This would also help with implementing repeat properly, and static
    evaluation of types.
* do incremental unrolling on the size of inputs and holes we try?

