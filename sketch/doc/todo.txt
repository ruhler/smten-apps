
Features::
RECURSIVE_GENERATOR
  - have a generator which calls itself depending on the input value.
    To deal with this:
        bound number of appearances of a function on the stack to
        --bnd-inline-amount. Assert no more are needed.
        So, if you exceed the limit, assert false and return error.

ARRAY_HOLE
  * int [8] fu = ??;  Should be allowed.

SUB_ARRAY
  * tmp[1::2] = ...;  Should be allowed.

MOD_OPERATOR
  * support: t % ?? for int type.

PRAGMA
  * support: pragma options "--bnd-intbits 6";

FAIL_LAZY
  * divide by zero failure is not lazy for rem.
    We could fix this by: explicitly saying rem with 0 as the divider is
    error. (except, this doesn't seem to have actually fixed it...)
    Or by: in the threaded runtime, it should just work hopefully.

Features needed, by test case::
miniTest12.sk: RECURSIVE_GENERATOR
miniTest41.sk: SLOW? (It contains nested repeats of arbitrary depth)
miniTest49.sk: PRAGMA
miniTest50.sk: FAIL_LAZY
miniTest51.sk: ARRAY_HOLE
miniTest52.sk: DIV_OPERATOR
miniTest53.sk: SUB_ARRAY
miniTest54.sk: SUB_ARRAY
miniTest55.sk: SUB_ARRAY
miniTest60.sk: SUB_ARRAY
miniTest62.sk: SUB_ARRAY
miniTest68.sk: SUB_ARRAY
miniTest69.sk: SUB_ARRAY
miniTest70.sk: SUB_ARRAY

Refactor Ideas::
* Do more stuff in Static pass
    * Loops can be unrolled properly if bounds known statically.
    * We can inline generator functions here.

Performance Ideas:: (consider only AFTER we run into performance problems)
* split a program into independent pieces if there are any?
* perform simplification at start to avoid re-evaluating things we know every
  iteration of the CEGIS loop?
    This would also help with implementing repeat properly, and static
    evaluation of types.
* do incremental unrolling on the size of inputs and holes we try?

Document Behaviors of sketch::
* What happens to: ??[4] in terms of type inference?
    blows up
* what happens to: 7[2] in terms of type inference?
    blows up

