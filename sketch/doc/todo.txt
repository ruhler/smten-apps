Features::
GENERATORS
  - To implement:
      Inline, then deHole. This should be done at generation time.
    Note: needs syntax for function calls, and presumably support for normal
    function calls (which deHole before inlining).

CHOICE - {|} hole generator
  - To implement: deHoleExpr should use mplus on both cases.
    This is relatively easy to implement.
    
BIT2INT - case bit to int
  - To implement: make an ite tree. Relatively easy.

REPEAT - support the 'repeat' keyword
  - Just another kind of statement. Relatively easy.

ASSERT - support assert statements
  - Using the existing support for assertions during eval, this should be easy
    to implement.

HOLE_WIDTH - support for specified width holes
  - To implement: easy, add a bound to a hole, handle in deHoleExpr.

FOR - support for loops
  
INTARRAY - int arrays

Operators (easy to implement):
 LOR: || boolean operator 
 SUB - '-' operator
 LT - '<' operator
 EQ - '==' operator
 PREINC - '++' prefix operator
 INTPLUS - integer plus


Features needed, by test case:;
miniTest5.sk: GENERATORS
miniTest8.sk: FOR
miniTest10.sk: ASSERT, HOLE_WIDTH, GENERATOR, EQ
miniTest11.sk: DYNAMIC_WIDTH, GENERATOR
miniTest12.sk: SUB, GENERATOR, 
miniTest14.sk: REPEAT
miniTest15.sk: BIT2INT
miniTest16.sk: BIT2INT
miniTest17.sk: GENERATOR, FOR, PREINC, LT
miniTest18.sk: LT, ASSERT< BIT2INT
miniTest19.sk: GENERATOR
miniTest20.sk: HOLE_WIDTH
miniTest21.sk: REPEAT, PREINC, BIT2INT
miniTest24.sk: LT, GT, ASSERT
miniTest25.sk: GENERATOR
miniTest28.sk: ASSERT,
miniTest29.sk: REPEAT
miniTest30.sk: INTPLUS, GENERATOR
miniTest31.sk: CHOICE, LOR

Performance Ideas:: (consider only AFTER we run into performance problems)
* split a program into independent pieces if there are any?
* perform simplification at start to avoid re-evaluating things we know every
  iteration of the CEGIS loop?
* do incremental unrolling on the size of inputs and holes we try?

Other Todo::
* make the pretty printer print prettier
* reuse BlockS for handling function bodies? 
* clean up type inference (leverage an smt solver?)

Document Behaviors of sketch::
* if you call a function in two different sketches, are it's holes shared or
  duplicated? (that is, do we need to do everything at once, or one sketch at
  a time?)
* What happens to: ??[4] in terms of type inference?
    blows up
* what happens to: 7[2] in terms of type inference?
    blows up

