
Features::
RECURSIVE_GENERATOR
  - have a generator which calls itself depending on the input value.
    To deal with this:
        bound number of appearances of a function on the stack to
        --bnd-inline-amount. Assert no more are needed.
        So, if you exceed the limit, assert false and return error.

POOR_TYPE_BIT_LITERAL
  * bit N = 5;

UNINTERPRETED_FUNCTION
  * Support: int moo(int x);   at top level.

UNIFY_INT_BIT
  * int and bit should unify to int.

ARRAY_ACCESS_BUG
  * array access is encountering a non-array thing
    Why isn't this caught by static typing?

INT_SHIFTL
  * Support: int exp = 1 << (K*2)
        for K int

OUT_OF_BOUNDS_ACCESS
  * looks like an out of bounds array access.
    Is this another example of FAIL_LAZY? The only place we do !! is in array
    access, and we have an assertion to avoid issues...

STRUCT_TYPES
  * support struct types.

REORDER
  * support reorder block

2D_UPDATE
  * support 2d array update: T[2][1] = 1;
    And, ideally, any dimension array update.

FAIL_LAZY
  * divide by zero failure is not lazy for rem.
    We could fix this by: explicitly saying rem with 0 as the divider is
    error. (except, this doesn't seem to have actually fixed it...)
    Or by: in the threaded runtime, it should just work hopefully.
  

Features needed, by test case::
miniTest12.sk: RECURSIVE_GENERATOR
miniTest41.sk: SLOW? (It contains nested repeats of arbitrary depth)
miniTest50.sk: FAIL_LAZY
miniTest54.sk: INT_SHIFTL
miniTest78.sk: POOR_TYPE_BIT_LITERAL
miniTest84.sk: OUT_OF_BOUNDS_ACCESS
miniTest86.sk: OUT_OF_BOUNDS_ACCESS
miniTest89.sk: SLOW? (quadratic in int space?)
miniTest93.sk: UNINTERPRETED_FUNCTION
miniTestb101.sk: UNINTERPRETED_FUNCTION
miniTestb102.sk: ARRAY_ACCESS_BUG
miniTestb103.sk: SLOW? Not sure why
miniTestb104.sk: SLOW?
miniTestb107.sk: SLOW?
miniTestb110.sk: SLOW?
miniTestb111.sk: STRUCT_TYPES
miniTestb112.sk: REORDER
miniTestb113.sk: 2D_UPDATE
miniTestb114.sk: STRUCT_TYPES
miniTestb116.sk: STRUCT_TYPES

Pretty Print::
* in type errors: pretty print types, don't just "show" them
* is it safe to print bit as 'true' and 'false'? What if they are used as int?
* don't need parens around integer literals
* 'for loop' init and incr don't print properly

Options:: (like --bnd-ictrl, --bnd-inbits, etc...)
* Understand what they are, what they are called, and what they really do
* Implement them properly
* Accept them from the command line
* Accept them in the form of pragmas

Refactor Ideas::
* Do more stuff in Static pass
    * Loops can be unrolled properly if bounds known statically.
    * We can inline generator functions here.

Performance Ideas:: (consider only AFTER we run into performance problems)
* split a program into independent pieces if there are any?
* perform simplification at start to avoid re-evaluating things we know every
  iteration of the CEGIS loop?
    This would also help with implementing repeat properly, and static
    evaluation of types.
* do incremental unrolling on the size of inputs and holes we try?

