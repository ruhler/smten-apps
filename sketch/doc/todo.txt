Features::
POOR_TYPE_BIT_LITERAL
  * bit N = 5;
  Works at global scope after inlining, but not locally.
  I think this is a bug in the original sketch implementation. Should I
  emulate the bug, or try to have them fix the original sketch implementation?

UNINTERPRETED_FUNCTION
  * Support: int moo(int x);   at top level.
  Not sure how to implement this.

STRUCT_TYPES
  * support struct types.

REORDER
  * support reorder block
  Not clear what reorder block is, though intuitively, it's any permutation of
  the given statements.
    reorder { a; b }
   is: 
    bit x = ??; 
    if x { a ; b} else { b ; a }
  or: bit x = ??;
      if x { a }
      b
      if !x { a } 
    reorder { a; b; c}
        is:   a ; reorder { b; c}
           |  b ; reorder { a; c}
           |  c ; reorder { a; b}
  or: int x0 = ??;
      int x1 = ??;
      int x2 = ??;
      assert (x0 != x1)
      assert (x0 != x2)
      assert (x1 != x2)
      case x0 of
        0 -> a
        1 -> b
        2 -> c
      case x1 of
        0 -> a
        1 -> b
        2 -> c
      case x2 of
        0 -> a
        1 -> b
        2 -> c
    

2D_UPDATE
  * support 2d array update: T[2][1] = 1;
    And, ideally, any dimension array update.

STATIC_EVAL::
  Evaluate local variables statically if possible.
  Because we might have:
    int x = foo(K);
    bit bar[x] = ...
  So we have to inline x to know the type of bar.
  Question: don't we already have some infrastructure for this?

TYPEOFV_SLOW
 80% time is spent in typeofV, and the program doesn't finish.
 Perhaps a bug or an infinite loop there?

INSERTVAR_SLOW
 95% time is spent in insertVar, and the program doesn't finish.
 Particularly, that 95% is a result of a seemingly exponential blowup of calls
 to PRIM_INT_EQ, PRIM_INT_LEQ, and PRIM_INT_ADD.
 Ex: 175 calls to PRIM_INT_ADD lead to about 17 million calls to select.

INTEQ_SLOW
 All the time is spent in Int equality. Perhaps some algebraic 
 simplifications are needed?

Features needed, by test case::
broken/miniTest48.sk: SLOW?
  Stack overflow
broken/miniTest49.sk: INSERTVAR_SLOW
broken/miniTest52.sk: INSERTVAR_SLOW
miniTest54.sk: STATIC_EVAL
miniTest78.sk: POOR_TYPE_BIT_LITERAL
miniTest86.sk: INSERTVAR_SLOW
miniTest93.sk: UNINTERPRETED_FUNCTION
miniTestb101.sk: UNINTERPRETED_FUNCTION
miniTestb102.sk: TYPEOFV_SLOW
miniTestb103.sk: TYPEOFV_SLOW
miniTestb104.sk: TYPEOFV_SLOW
miniTestb107.sk: TYPEOFV_SLOW
miniTestb110.sk: INSERTVAR_SLOW
miniTestb111.sk: STRUCT_TYPES
miniTestb112.sk: REORDER
miniTestb113.sk: 2D_UPDATE
miniTestb114.sk: STRUCT_TYPES
miniTestb116.sk: STRUCT_TYPES
miniTestb118.sk: INSERTVAR_SLOW
miniTestb121.sk: INTEQ_SLOW

Pretty Print::
* in type errors: pretty print types, don't just "show" them
* is it safe to print bit as 'true' and 'false'? What if they are used as int?
* don't need parens around integer literals
* 'for loop' init and incr don't print properly

Refactor Ideas::
* Do more stuff in Static pass
    * Loops can be unrolled properly if bounds known statically.
    * We can inline generator functions here.

Performance Ideas:: (consider only AFTER we run into performance problems)
* split a program into independent pieces if there are any?
* perform simplification at start to avoid re-evaluating things we know every
  iteration of the CEGIS loop?
    This would also help with implementing repeat properly, and static
    evaluation of types.
* do incremental unrolling on the size of inputs and holes we try?

