
Features::
RECURSIVE_GENERATOR
  - have a generator which calls itself depending on the input value.
    To deal with this:
        bound number of appearances of a function on the stack to
        --bnd-inline-amount. Assert no more are needed.
        So, if you exceed the limit, assert false and return error.

PRAGMA
  * support: pragma options "--bnd-intbits 6";
    3. Read bnd_foo parameters from the command line
    4. Read bnd_foo parameters from the options pragma.
    5. Parse string literals
    6. Parse pragma

BULK_ARRAY_EVAL
  * Support dynamic BULK_ARRAY bounds

POOR_TYPE_BIT_LITERAL
  * bit N = 5;

AMBIGUOUS_INT_LITERAL
  * (0 == 0), the type of the integer literal is ambiguous.

UNINTERPRETED_FUNCTION
  * Support: int moo(int x);   at top level.

UNIFY_INT_BIT
  * int and bit should unify to int.

ARRAY_ACCESS_BUG
  * array access is encountering a non-array thing
    Why isn't this caught by static typing?

INT_SHIFTL
  * Support: int exp = 1 << (K*2)
        for K int

FAIL_LAZY
  * divide by zero failure is not lazy for rem.
    We could fix this by: explicitly saying rem with 0 as the divider is
    error. (except, this doesn't seem to have actually fixed it...)
    Or by: in the threaded runtime, it should just work hopefully.
  

Features needed, by test case::
miniTest12.sk: RECURSIVE_GENERATOR
miniTest41.sk: SLOW? (It contains nested repeats of arbitrary depth)
miniTest50.sk: FAIL_LAZY
miniTest54.sk: INT_SHIFTL
miniTest60.sk: BULK_ARRAY_EVAL
miniTest62.sk: BULK_ARRAY_EVAL
miniTest68.sk: BULK_ARRAY_EVAL
miniTest78.sk: POOR_TYPE_BIT_LITERAL
miniTest82.sk: BULK_ARRAY_EVAL
miniTest83.sk: BULK_ARRAY_EVAL
miniTest84.sk: BULK_ARRAY_EVAL
miniTest86.sk: BULK_ARRAY_EVAL
miniTest86.sk: BULK_ARRAY_EVAL
miniTest89.sk: SLOW? (quadratic in int space?)
miniTest91.sk: AMBIGUOUS_INT_LITERAL
miniTest92.sk: BULK_ARRAY_EVAL
miniTest93.sk: UNINTERPRETED_FUNCTION
miniTestb101.sk: UNINTERPRETED_FUNCTION
miniTestb102.sk: ARRAY_ACCESS_BUG
miniTestb103.sk: SLOW? Not sure why

Pretty Print::
* don't need parens around integer literals
* for loop init and incr don't print properly

Options::
* Understand what they are, what they are called, and what they really do

Refactor Ideas::
* Do more stuff in Static pass
    * Loops can be unrolled properly if bounds known statically.
    * We can inline generator functions here.

Performance Ideas:: (consider only AFTER we run into performance problems)
* split a program into independent pieces if there are any?
* perform simplification at start to avoid re-evaluating things we know every
  iteration of the CEGIS loop?
    This would also help with implementing repeat properly, and static
    evaluation of types.
* do incremental unrolling on the size of inputs and holes we try?

