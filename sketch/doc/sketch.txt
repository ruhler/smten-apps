The Sketch Language
===================
Richard Uhler <ruhler@csail.mit.edu>
September 2013

Introduction
------------
This document describes the syntax and semantics of the Sketch language, as
discovered for the purposes of re-implementing sketch.

Types
------
  bit     - a single bit: true or false
  char    - a character: (8 bit?)
  int     - an integer: range specified by --bnd-inbits flag. Defaults to 5,
            in practice works up to 7 or 8 bits.
  bit[<n>]   - an array of n bits

Expressions
-----------
    <expr> & <expr> 
        Bitwise AND. Works on bit, bit[], (others?).
        Does not have short circuit semantics.

    <expr> && <expr>
        Logical AND. Works on bit, (others?).
        Has short circuit semantics.

    ! <expr>
        Logical NOT. Works on bit, bit[].

    ~ <expr>
        Logical Not. Same as '!' operator. (really?).

    <expr> | <expr> 
        Bitwise OR. Works on bit, bit[], (others?).
        Does not have short circuit semantics.

    <expr> || <expr>
        Logical OR. Works on bit, (others?).
        Has short circuit semantics.

    <expr> + <expr>
        Addition. Works on bit[] and int. Does not work on bit.

    <expr> - <expr>
        Subtraction. Works on int. Does not work on bit or bit[].

    <expr> * <expr>
        Multiplication. Works on int. Does not work on bit or bit[].

    <expr> < <expr>
        Less than. Works on int. Does not work on bit or bit[].

    <expr> > <expr>
        Greater than. Works on int. Does not work on bit or bit[].

    <expr> == <expr>
        Equal to. Works on int, bit, and bit[].

    <expr> >> <expr>
        Logical right shift. The left argument must be an array of bits. The
        right argument has type int.

    <expr> << <expr>
        Logical left shift. The left argument must be an array of bits. The
        right argument has type int.

    <expr> [<expr>]
        Array access. The array must have an array type (bit arrays are
        allowed). The index must have Int type. Returns the value of the array
        at the given index.

        Array access is bounds checked:
        "For every array access a[i] the synthesizer produces an assertion
         assert i>=0 && i<len(a) so the synthesizer will reject your program
         if there is any input that will cause the assertion to fail."
        (I'm not sure what that means though)

    {<expr>, <expr>, ..., <expr>}
        Array literal.

    (<type>) <expr>
        Explicit cast.
        Casts supported are:
          - T[N] to T[M] - expands or truncates as needed
          - bit[N] to Int 
          - float to integer, or integer to float

Holes
-----
    ??       - a free bit, char, bits, int, or constant width array expression.
    ??(N)    - a free constant between 0 and less than 2^N, with N an integer
               constant. That is, N is the number of bits for the hole.
    {*}      - Same as '??'     (is it really?)
    <expr> {|} <expr>
        - Bitwise choose between the bits of the given expressions.
          Both arguments must have type bit[].
          The expression (a {|} b), is like saying:
            bit[N] x = ??;
            (a & x) | (b & ~x)
            
        


Statements
----------
    return <expr> ;
      - set the result of the current function to the value of <expr>

    assert <expr> ;
      - assert the expression holds.

    <type> <name> ;
      - Declare the variable <name> to have <type>.
        The value of the variable is initialized to:
           bit[]:  initial value is 0.
           bit: no initial value is provided (it is an error to use it).
           int: no initial value is provided (it is an error to use it).
        Note: local variables may NOT be shadowed.

    <type> <name> = <expr> ;
      - Declare the variable <name> to have <type> and initial value <expr>
        Note: local variables may NOT be shadowed.

    <lval> = <expr> ;
      - Update the left hand side value <lval> to have value <expr>
      where lval can be:    <name>          - update the variable
                     or:    <name>[<expr>]  - update a specific array element

    if (<expr>) <stmt>  [else <stmt>]
      - evaluate the condition. If it is true, evaluate the statement,
        otherwise, if there is an else block, execute that, otherwise do
        nothing.  <expr> has type bit (and others?)

    { <stmts> }
      - evaluate each statement in turn.

    repeat(<expr>) <stmt>
      - The argument should be an int. Repeats the given statement that many
        times.

    while (<expr>) <stmt>
      - The argument should be a bit. Repeatedly executes the given statement
        while the argument evaluates to True.

    for (<init> ; <expr> ; <incr>) <body>
      - Standard for loop.
        Question: What exactly can go in <init> and <incr> slots?

    ++<name> 
      - Sugar for: <name> = <name> + 1

Declarations
------------
    <type> <name> (<type> <name>, <type <name>, ...) { <stmts> }
        Define a function. If the function does not contain any holes, it may
        be used as a specification.

    <type> <name> (<type> <name>, <type <name>, ...) implements <name> { <stmts> }
        Define a sketch with holes implementing the given specification.
        The sketch tool will fill in the holes for each sketch such that the
        behavior of the sketch matches the behavior of its specification.

        The sketch tool will report an error if no assignment of holes makes
        the behavior of the sketch match the behavior of its specification.

    generator <type> <name> (<type> <name>, <type <name>, ...) { <stmts> }
        Define a generator. The generator may contain holes. Whenever a
        generator is called, it is inlined before assigning names to the
        holes. That is, every place the generator is inlined makes a new,
        independent copy of all the holes in the generator.

    <type> <name> = <expr> ;
        Global variable declaration.
    
